Here is your **v3.md** — fully structured, Windsurf-ready, and containing all the decisions we locked in.
It is clean, explicit, and designed so Windsurf can rebuild the entire integration **from scratch** using the original folder only as optional reference.

Below is the full Markdown file.
**You can copy/paste it directly into a `v3.md` file.**

---

# **Virtual Gas Meter – v3 Specification**

Rebuild From Scratch

This document defines the complete specification for **Virtual Gas Meter v3**, a Home Assistant custom integration rebuilt **entirely from fresh code**.
The original implementation has been moved to:

```
custom_components/gas_meter_original/
```

This folder exists only for reference. **No legacy code should be reused.**

---

# **1. Goals**

* Provide a **virtual gas meter** that estimates consumption based on boiler runtime.
* Allow users to calibrate the virtual meter using **real gas meter readings**.
* Support **two unit systems**:

  * `m3` (cubic meters)
  * `CCF` (hundred cubic feet)
* Maintain high accuracy over time by recalculating the user-defined **average hourly gas consumption rate**.
* Ensure **all state persists** across Home Assistant restarts.
* Provide a clean, reliable, minimal entity set.
* Provide a config flow for UI setup.
* Only **one instance** of the integration may exist (one boiler).

Bill Entry Mode and all related functionality are **removed** in v3.

---

# **2. Non-Goals**

* No historical “bill consumption” logging.
* No multiple boiler support.
* No automatic meter reading import from hardware.
* No runtime backfilling if HA is offline.

---

# **3. Unit Handling**

Users choose either:

* `m3`
* `CCF`

This unit is:

* Locked at setup.
* Cannot be changed later (must remove & re-add integration to change units).
* Stored in config entry.
* Used for **all user inputs, all sensor outputs**, and consumption calculations.

Internally, the integration **may store data in m³**, but all values must be converted to the chosen unit on input/output.

All numeric inputs/outputs use **3 decimal places**, regardless of unit.

---

# **4. Sensors**

The integration exposes **three sensors**.
No others.

## **4.1 sensor.vgm_gas_meter_total**

**Primary Energy Dashboard Source**

* **State:**

  * Float (3 dp), absolute virtual gas meter reading in the chosen unit.
  * Monotonically increasing unless manually reset via a real meter reading update.

* **Device Class:** `gas`

* **State Class:** `total_increasing`

* **Unit:** `"m³"` or `"CCF"`

* **Attributes:**

  * `last_real_meter_reading` — Float, chosen unit, 3 dp
  * `last_real_meter_timestamp` — ISO datetime
  * `average_rate_per_h` — Float, chosen unit/hour, 3 dp
  * `boiler_entity_id` — string
  * `unit` — `"m3"` or `"CCF"`

---

## **4.2 sensor.vgm_consumed_gas**

**Estimated gas consumed since last real reading**

* Float, 3 dp, chosen unit.
* Resets to `0.000` when a real meter reading update is applied.
* Increases while boiler is running based on `average_rate_per_h`.

---

## **4.3 sensor.vgm_heating_interval**

**Readable boiler runtime since last real reading**

* String format: `"Xh Ym"` (e.g. `"2h 37m"`).
* Internally tracked using minutes/seconds.
* Resets to `"0h 0m"` on real meter reading updates.

No attribute equivalents for heating interval exist.

---

# **5. Service: Real Meter Reading Update**

Only one service exists in v3.

## **Service ID:**

```
gas_meter.real_meter_reading_update
```

## **Friendly Name:**

**Real Meter Reading Update**

## **Parameters:**

| Parameter                  | Type     | Description                                                         |
| -------------------------- | -------- | ------------------------------------------------------------------- |
| `meter_reading`            | float    | New real meter reading (chosen unit, 3 dp). Required.               |
| `timestamp`                | datetime | Optional. If omitted, defaults to now().                            |
| `recalculate_average_rate` | bool     | Default `true`. If false, snap total but do not update hourly rate. |

---

## **Service Behaviour**

Let:

* `last_real` = previous real meter reading
* `t_last` = timestamp of previous real reading
* `runtime_minutes` = boiler runtime between `t_last` and `timestamp`
* `runtime_hours = runtime_minutes / 60`

### **1. Validation**

If `meter_reading < last_real`:

* Log **ERROR** (clear message).
* Abort update.
* Do **not** silently ignore anything.

### **2. Runtime == 0**

If boiler runtime in this period is zero:

* Set:

  * `last_real_meter_reading = meter_reading`
  * `vgm_gas_meter_total = meter_reading`
  * `vgm_consumed_gas = 0.000`
  * `vgm_heating_interval = "0h 0m"`
* Do not recalc average rate.

### **3. Recalculate average rate (if enabled)**

Only if:

```
runtime_minutes > 0 AND recalculate_average_rate == true
```

Then:

```
actual_used = meter_reading - last_real
average_rate_per_h = actual_used / runtime_hours
```

No caps.
No clamping.
No hidden behaviour.

### **4. Apply result**

On successful update:

* Update attributes on `vgm_gas_meter_total`
* Reset:

  * `vgm_consumed_gas = 0.000`
  * `vgm_heating_interval = "0h 0m"`
* `vgm_gas_meter_total.state = meter_reading`

---

# **6. Runtime Tick Behaviour**

Runtime ticks occur every **60 seconds** while boiler is ON.

Each tick:

1. Increase internal runtime counter by 1 minute.
2. Update `vgm_heating_interval` (`Xh Ym`).
3. Add:

   ```
   consumed_increment = average_rate_per_h / 60
   ```

   to `vgm_consumed_gas`.
4. Update:

   ```
   vgm_gas_meter_total = last_real_meter_reading + vgm_consumed_gas
   ```

### Boiler turns off

When boiler changes from `on → off`, perform one immediate tick to close the run.

### Home Assistant restart

On restart:

* Restore all persisted values.
* **Do not** retroactively add runtime for downtime — runtime is always zero when HA is not running.

---

# **7. Config Flow**

Integration must be fully configurable from UI.

## **Config Step 1: User Input**

User selects:

* **Boiler entity** (allowed domains):

  * `switch`
  * `climate`
  * `binary_sensor`
  * `sensor`
    (Must represent an ON/OFF concept)

* **Unit selection**:

  * `m3`
  * `CCF`

* **Initial real meter reading** (float, chosen unit, 3 dp)

* **Initial average hourly consumption** (float, chosen unit/hour, 3 dp)

## **Config Step 2: Confirmation**

Show summary → Create config entry.

## **Single-Instance Enforcement**

If an entry already exists:

* Abort with `"single_instance_allowed"`.
* UI message:
  “Virtual Gas Meter only supports one instance. Remove the existing one to reconfigure.”

## **Options Flow**

User may edit:

* Boiler entity
* Initial average hourly consumption

User may **not** edit:

* Unit selection
* Last real meter reading (except via service)

---

# **8. Device Definition**

Create a device:

**Name:** `Virtual Gas Meter`
**Manufacturer:** `Virtual Gas Meter`
**Model:** `Boiler Runtime Estimator`

Entities under device:

* `sensor.vgm_gas_meter_total`
* `sensor.vgm_consumed_gas`
* `sensor.vgm_heating_interval`

---

# **9. Persistence Requirements**

The integration must persist:

* `last_real_meter_reading`
* `last_real_meter_timestamp`
* `average_rate_per_h`
* `consumed_gas`
* `heating_interval` (internal counters, not just string)
* `unit`
* `boiler_entity_id`

Everything must survive HA restarts.

---

# **10. Logging Requirements**

### INFO-level logs:

* Integration loaded
* Successful `real_meter_reading_update` event:

  * Old reading
  * New reading
  * Runtime minutes
  * New average rate (if recalculated)

### DEBUG-level logs:

* Each 60-second tick:

  * Incremental consumption
  * Updated totals
  * Boiler state transitions

---

# **11. Removed Functionality**

v3 completely removes:

* Bill Entry Mode
* `gas_meter.enter_bill_usage`
* `gas_meter.read_gas_actualdata_file`
* All old sensors including:

  * `gas_consumption_data`
  * `operating_mode`
  * `unit_system`
  * `boiler_entity`
  * previous heating interval attributes
* All CCF/m³ logic from legacy implementation (replaced with new unit system)

---

# **12. README Update Checklist**

For every implementation step below, Windsurf must:

* Update README to remove legacy content
* Add updated documentation for:

  * Config flow
  * Units
  * Sensors (3 total)
  * Service (`real_meter_reading_update`)
  * Expected behaviour & examples

---

# **13. Implementation Checklist**

## **Core Integration**

* [ ] Build integration fresh inside `custom_components/gas_meter`
* [ ] Do not reuse old code (reference only)
* [ ] Enforce single instance

## **Unit System**

* [ ] Implement selectable units (`m3` / `CCF`)
* [ ] Normalise conversion internally if desired
* [ ] Ensure all inputs/outputs use chosen unit
* [ ] Enforce 3 decimal places
* [ ] Block unit changes after creation
* [ ] README updated

## **Sensor Implementation**

* [ ] Implement `sensor.vgm_gas_meter_total`
* [ ] Implement `sensor.vgm_consumed_gas`
* [ ] Implement `sensor.vgm_heating_interval`
* [ ] Ensure correct units, classes, persistence
* [ ] README updated

## **Service: real_meter_reading_update**

* [ ] Implement parameter parsing
* [ ] Validation (reading < previous → error)
* [ ] Recalculation logic
* [ ] Snap logic (runtime=0)
* [ ] Consumption reset
* [ ] Persistence updates
* [ ] README updated

## **Runtime Engine**

* [ ] Boiler state listener
* [ ] 60-second update loop
* [ ] Final update on “off” transition
* [ ] No retroactive runtime after restart
* [ ] README updated

## **Config Flow**

* [ ] UI setup page
* [ ] Domain filter for allowed entity types
* [ ] Summary page
* [ ] Single instance enforcement
* [ ] Options flow
* [ ] README updated

## **Device Setup**

* [ ] Create device + attach entities
* [ ] Add manufacturer/model
* [ ] README updated

## **Persistence**

* [ ] Use HA Store API
* [ ] Persist all required values
* [ ] README updated

## **Logging**

* [ ] INFO logs for major events
* [ ] DEBUG logs for ticks
* [ ] README updated

---

# **End of v3 Specification**

---